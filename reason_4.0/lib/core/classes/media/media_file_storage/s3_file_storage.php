<?php

include_once('reason_header.php');
require_once(SETTINGS_INC.'media_integration/s3_storage_settings.php');
reason_include_once('classes/media/media_file_storage/media_file_storage.php');
require_once(INCLUDE_PATH.'s3/S3.php');

/**
 * Class that manages media files with Amazon's S3 service.
 * 
 * @author Marcus Huderle
 *
 */
class S3MediaFileStorageClass extends MediaFileStorageClass
{	
	/**
	 * Uploads a file to S3 storage bucket
	 *.
	 * @param $media_file_or_id entity or integer
	 * @param $filepath string
	 * @param $custom_filename string (optional name of file to be stored)
	 * @param $media_work entity
	 * @param $extra_dir string
	 * @return mixed location of where it was stored or false. (ex: 'https://s3.amazonaws.com/BUCKET_NAME/...rest of path'
	 */
	public static function store_media($media_file_or_id, $filepath, $custom_filename = '', $media_work = null, $extra_dir = '')
	{
		$client = self::_get_client();
		if ($client)
		{
			if (!$custom_filename)
			{
				$filename = basename($filepath);
			}
			else
			{
				$filename = $custom_filename;
			}
			if ($storage_path = parent::get_path($media_file_or_id, $filename, $media_work, $extra_dir))
			{
				// specify the custom filename instead of the one generated by get_path()
				if ($custom_filename)
				{
					$storage_path = str_replace(basename($storage_path), $custom_filename, $storage_path);
				}
				if(strpos($filepath, "http") === 0)
				{
					return S3_BASE_URL.S3_BUCKET_NAME.'/'.$storage_path;
				}
				else
				{
					$fp = fopen($filepath, 'r');
					$filesize = filesize($filepath);
				
					$input = S3::inputResource($fp, $filesize);
				
					if ($client->putObject($input, S3_BUCKET_NAME, $storage_path, S3::ACL_PUBLIC_READ, array(), self::_get_content_type($media_file_or_id, $filename)))
					{
						return S3_BASE_URL.S3_BUCKET_NAME.'/'.$storage_path;
					}
					else
					{
						trigger_error('Upload to S3 failed.');
					}
				}
			}
			else
			{
				trigger_error('An invalid storage path was created.');
			}
		}
		else
		{
			trigger_error('Could not create client object for interacting with S3 service.');
		}
		return false;
	}
	
	/**
	 * Deletes the file from the file system.
	 * @param $media_file_or_id entity or integer
	 * @return boolean true if successful; false otherwise
	 */
	public static function delete_media($media_file_or_id, $media_work = null, $extra_dir = '')
	{
		$client = self::_get_client();
		if ($client)
		{
			if (is_object($media_file_or_id))
			{
				$id = $media_file_or_id->id();
			}
			else
			{
				$id = $media_file_or_id;
			}
			$media_file = new entity($id);
			$filename = self::_get_filename_from_media_file($media_file);
		
			if ($storage_path = parent::get_path($media_file_or_id, $filename, $media_work, $extra_dir))
			{
				try
				{
					if ($client->deleteObject(S3_BUCKET_NAME, $storage_path))
					{
						return true;
					}
					else
					{
						trigger_error('Could not delete file at '.$full_storage_path.'.');
					}
				}
				catch (Exception $e) 
				{}
			}
			else
			{
				trigger_error('An invalid storage path was created.');
			}
		}
		else
		{
			trigger_error('Could not create client object for interacting with S3 service.');
			return false;
		}
	}
	
	/**
	 * Deletes the original file of a media work
	 * @param $media_work entity
	 */
	public static function delete_original_media($media_work)
	{
		$client = self::_get_client();
		if ($client)
		{
			$path = parent::get_path('', '', $media_work, 'original');
			if ($path)
			{
				try 
				{
					$client->deleteObject(S3_BUCKET_NAME, $path);
				}
				catch (Exception $e)
				{}
			}
		}
		else
		{
			trigger_error('Could not create client object for interacting with S3 service.');
			return false;
		}	
	}
	
	/**
	 * Creates the client object used for interacting with S3.
	 * @return $obj
	 */
	public static function _get_client()
	{
		return new S3(S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY);
	}
	
	/**
	 * Build the mime type for this file because we need to tell S3 what the mime type is when
	 * it is uploaded.
	 * @param $media_file_or_id
	 * @param $filepath string
	 * @return string
	 */
	private static function _get_content_type($media_file_or_id, $filepath)
	{
		$type = '';
		if (!$media_file_or_id)
		{
			return null;
		}
		if (!is_object($media_file_or_id))
		{
			$media_file_or_id = new entity($media_file_or_id);
		}
		if ($media_file_or_id->get_value('av_type') == 'Video')
		{
			$type = 'video/';
		}
		elseif ($media_file_or_id->get_value('av_type') == 'Audio')
		{
			$type = 'audio/';
		}
		else
		{
			return null;	
		}
		
		$extension = pathinfo($filepath, PATHINFO_EXTENSION);
		if ($extension == 'ogg') {
			$type .= 'ogg';
		} elseif ($extension == 'mp4') {
			$type .= 'mp4';
		} elseif ($extension == 'mp3') {
			$type .= 'mpeg';
		} elseif ($extension == 'webm') {
			$type .= 'webm';
		} elseif ($extension == 'mp4') {
			$type .= 'mp4';
		}
		return $type;
	}
	
	/**
	 * Returns the base url for the web available files.
	 * @return string
	 */
	public static function get_base_url()
	{
		return S3_BASE_URL.S3_BUCKET_NAME.'/';
	}
	
	/**
	 * Deletes the still images associated with the media work being deleted.
	 *
	 * @param $media_work
	 * @param $num number of still images to delete
	 */
	public static function delete_media_work_stills($media_work, $num)
	{	
		$client = self::_get_client();
		if (!$client)
		{
			trigger_error('Could not create S3 object.');
			return;
		}
		$stills_path = self::get_path('', 'placeholder.jpg', $media_work, 'stills');
		$stills_path = str_replace(basename($stills_path), '', $stills_path);
		
		for ($i = 0; $i < $num; $i += 1)
		{
			if (!$client->deleteObject(S3_BUCKET_NAME, $stills_path.$i.'.jpg'))
			{
				trigger_error('Could not delete still '.$i.' for media work '.$media_work->id().'.');
			}
		}
	}
	
	/**
	 * Returns the base path for stills.
	 *
	 * @param $media_work
	 */
	public static function get_stills_base_url($media_work)
	{
		$stills_directory = self::get_destination_url_for_transcoded_file(false, 'jpg', $media_work, 'stills');
 		$stills_directory = str_replace(basename($stills_directory), '', $stills_directory);
 		
 		return $stills_directory;
 	}
	
	/**
	 * Updates metadata on media file.
	 *  
	 * @param $values array
	 * @param $type string
	 * @param $media_work entity
	 * @param $media_file entity
	 */
	public static function update_video_media_file_in_notification_receiver($values, $type, $media_work, $media_file)
	{
		$values['download_url'] = $values['url'];
		reason_update_entity($media_file->id(), $media_work->get_owner()->id(), $values, false);
	}
	
	/**
	 * Updates metadata on media file.
	 *  
	 * @param $obj object
	 * @param $type string
	 * @param $media_work entity
	 * @param $media_file entity
	 * @param $mime_types array
	 */
	public static function update_audio_media_file_in_notification_receiver($values, $type, $media_work, $media_file)
	{
		$values['download_url'] = $values['url'];
		reason_update_entity($media_file->id(), $media_work->get_owner()->id(), $values, false);
	}
	
	/**
	 * Returns the url that a transcoded file should be placed when it has completed transcoding.
	 * This function is used by Zencoder, specifically.
	 * 
	 * @param $media_file_id string/int
	 * @param $file_extension string
	 */
	public static function get_destination_url_for_transcoded_file($media_file_id, $file_extension, $media_work, $extra_dir = '')
	{
		return self::get_base_url().self::get_path($media_file_id, 'placeholder.'.$file_extension, $media_work, $extra_dir);
	}
	
	/**
	 * Called in the Zencoder notification receiver after the Reason media work entity has been created.
	 * Videos require no special treatment here.
	 * 
	 * @param $filepath
	 * @param $media_work
	 */
	public static function post_process_video($filepath, $media_work)
	{}
	
	/**
	 * Called in the Zencoder notification receiver after the Reason entity has been created.
	 * This hooks up the original mp3 or ogg file to a Reason entity, if needed.
	 *
	 * @param $filepath string
	 * @param $media_work entity
	 * @param $num_outputs int
	 * @param $shim obj
	 * @param $netid string
	 */
	public static function post_process_audio($filepath, $media_work, $num_outputs, $shim, $netid)
	{
		// We need to create a media file for the source mp3 or ogg file
		if ($num_outputs == 2)
		{			
			$filename = end((explode('/', $filepath)));
 			$extension = end((explode('.', $filename)));			
			if ($extension == 'mp3')
			{
				$mime_type = 'audio/mpeg';
			}
			elseif ($extension == 'ogg')
			{
				$mime_type = 'audio/ogg';
			}
			else
			{
				trigger_error('Invalid extension: '.$extension);
			}
			
			$path = self::get_path(false, $filename, $media_work, 'original');
			$base_url = self::get_base_url();
			
			$client = self::_get_client();
			if (!$client)
			{
				trigger_error('Could not create S3 object.');
				return;
			}
			
			$web_url = $base_url.$path;
			$obj_info_arr = $client->getObjectInfo(S3_BUCKET_NAME, $path);
			$filesize = $obj_info_arr['size'];
			
			$name = basename($web_url);
			$web_url = str_replace($name, urlencode($name), $web_url);
			
			$values = array(
				'av_type' => 'Audio',
				'flavor_id' => 'original',
				'media_format' => 'HTML5',
				'url' => $web_url,
				'download_url' => $web_url,
				'mime_type' => $mime_type,
				'media_size_in_bytes' => $filesize,
				'media_size' => format_bytes_as_human_readable($filesize),
				'media_quality' => $shim->_get_bitrate($filepath).' kbps',
				'media_duration' => $shim->_get_duration($filepath),
			);

			$media_file_id = reason_create_entity($media_work->get_owner()->id(), id_of('av_file'), get_user_id($netid), $media_work->get_value('name').' '.$extension, $values);
			create_relationship($media_work->id(), $media_file_id, relationship_id_of('av_to_av_file'));
		}
	}
	
	/**
	 * Zencoder requires an additional output to be specified in order to transfer the
	 * original file. 
	 * 
	 * @param $outputs array
	 * @param $filename string
	 * @param $media_work entity
	 * @param $shim object
	 * @param $av_type 'Video' or 'Audio'
	 */
	public static function add_additional_outputs($outputs, $filename, $media_work, $shim, $av_type)
	{
		$url = self::get_base_url().self::get_path(false, $filename, $media_work, 'original');
		$name = basename($url);
		$url = str_replace($name, urlencode($name), $url);
		$params = array(
			"type" => "transfer-only",
			"url" => $url,
			"public" => true,
			"label" => "original",
		);
		// also generate thumbnails if it's a Video
		$stills_directory = $shim->get_storage_class()->get_stills_base_url($media_work);
		if ($av_type == 'Video')
		{
			$params['thumbnails'] = array(			
				"number" => $shim->get_num_stills(),
				"format" => "jpg",
				"base_url" => $stills_directory,
				"filename" => "{{number}}",
			);
			$params['notifications'] = $shim->get_notification_receiver_url();
		}
		$outputs[] = $params;
		return $outputs;
	}
}
?>